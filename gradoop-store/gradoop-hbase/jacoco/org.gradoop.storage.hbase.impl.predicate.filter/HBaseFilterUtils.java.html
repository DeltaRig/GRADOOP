<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HBaseFilterUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop HBase</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.storage.hbase.impl.predicate.filter</a> &gt; <span class="el_source">HBaseFilterUtils.java</span></div><h1>HBaseFilterUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.storage.hbase.impl.predicate.filter;

import org.apache.hadoop.hbase.filter.BinaryComparator;
import org.apache.hadoop.hbase.filter.CompareFilter;
import org.apache.hadoop.hbase.filter.Filter;
import org.apache.hadoop.hbase.filter.FilterList;
import org.apache.hadoop.hbase.filter.FuzzyRowFilter;
import org.apache.hadoop.hbase.filter.RegexStringComparator;
import org.apache.hadoop.hbase.filter.RowFilter;
import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.hbase.util.Pair;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.id.GradoopIdSet;
import org.gradoop.common.model.impl.properties.PropertyValue;
import org.gradoop.common.model.impl.properties.PropertyValueUtils;
import org.gradoop.common.model.impl.properties.Type;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import static org.gradoop.storage.hbase.impl.constants.HBaseConstants.CF_META;
import static org.gradoop.storage.hbase.impl.constants.HBaseConstants.CF_PROPERTY_TYPE;
import static org.gradoop.storage.hbase.impl.constants.HBaseConstants.CF_PROPERTY_VALUE;
import static org.gradoop.storage.hbase.impl.constants.HBaseConstants.COL_LABEL;

/**
 * Utility class for common HBase filter tasks
 */
<span class="nc" id="L48">public class HBaseFilterUtils {</span>
  /**
   * Byte representation of meta data column family
   */
<span class="fc" id="L52">  private static final byte[] CF_META_BYTES = Bytes.toBytesBinary(CF_META);</span>
  /**
   * Byte representation of property value column family
   */
<span class="fc" id="L56">  private static final byte[] CF_PROPERTY_VALUE_BYTES = Bytes.toBytesBinary(CF_PROPERTY_VALUE);</span>
  /**
   * Byte representation of property type column family
   */
<span class="fc" id="L60">  private static final byte[] CF_PROPERTY_TYPE_BYTES = Bytes.toBytesBinary(CF_PROPERTY_TYPE);</span>
  /**
   * Byte representation of column qualifier
   */
<span class="fc" id="L64">  private static final byte[] COL_LABEL_BYTES = Bytes.toBytesBinary(COL_LABEL);</span>

  /**
   * Creates a HBase Filter object to return only graph elements that are equal to the given
   * GradoopIds.
   *
   * @param elementIds a set of graph element GradoopIds to filter
   * @param isSpreadingByteUsed indicates if the handlers using a spreading byte as prefix
   *                            of each row key
   * @return a HBase Filter object
   */
  public static Filter getIdFilter(GradoopIdSet elementIds, boolean isSpreadingByteUsed) {
    Filter filter;
<span class="fc bfc" id="L77" title="All 2 branches covered.">    if (isSpreadingByteUsed) {</span>
      // a spreading byte is used as prefix in row key, therefore a FuzzyRowFilter has to be used
<span class="fc" id="L79">      byte[] dummyByte = new byte[1];</span>

      // instantiate a list of byte array pairs for the fuzzy row filter
<span class="fc" id="L82">      List&lt;Pair&lt;byte[], byte[]&gt;&gt; fuzzyList = new ArrayList&lt;&gt;();</span>

      // create a byte array and set the first to '1' to identify the position of dynamic bytes
<span class="fc" id="L85">      byte[] fuzzyInfo = new byte[13];</span>
<span class="fc" id="L86">      fuzzyInfo[0] = (byte) 1;</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">      for (GradoopId gradoopId : elementIds) {</span>
        // for each id create a 13 byte long array from a dummy byte and the 12 byte gradoop id
<span class="fc" id="L90">        byte[] rowKey = Bytes.add(dummyByte, gradoopId.toByteArray());</span>
<span class="fc" id="L91">        fuzzyList.add(new Pair&lt;&gt;(rowKey, fuzzyInfo));</span>
<span class="fc" id="L92">      }</span>
<span class="fc" id="L93">      filter = new FuzzyRowFilter(fuzzyList);</span>
<span class="fc" id="L94">    } else {</span>
      // no spreading byte in row key, therefore a list of RowFilters has to be used

<span class="fc" id="L97">      FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ONE);</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">      for (GradoopId gradoopId : elementIds) {</span>
<span class="fc" id="L100">        RowFilter rowFilter = new RowFilter(</span>
          CompareFilter.CompareOp.EQUAL,
<span class="fc" id="L102">          new BinaryComparator(gradoopId.toByteArray())</span>
        );
<span class="fc" id="L104">        filterList.addFilter(rowFilter);</span>
<span class="fc" id="L105">      }</span>
<span class="fc" id="L106">      filter = filterList;</span>
    }
<span class="fc" id="L108">    return filter;</span>
  }

  /**
   * Creates a HBase Filter object representation of labelIn predicate
   *
   * @param labels set of labels to filter for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getLabelInFilter(@Nonnull Set&lt;String&gt; labels, boolean negate) {
    // Handle negation
<span class="fc bfc" id="L120" title="All 2 branches covered.">    CompareFilter.CompareOp compareOp = negate ? CompareFilter.CompareOp.NOT_EQUAL :</span>
      CompareFilter.CompareOp.EQUAL;
<span class="fc bfc" id="L122" title="All 2 branches covered.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ALL :</span>
      FilterList.Operator.MUST_PASS_ONE;

<span class="fc" id="L125">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L127">    labels.stream()</span>
<span class="fc" id="L128">      .map(label -&gt; new SingleColumnValueFilter(CF_META_BYTES, COL_LABEL_BYTES, compareOp,</span>
<span class="fc" id="L129">        Bytes.toBytesBinary(label)))</span>
<span class="fc" id="L130">      .forEach(filterList::addFilter);</span>

<span class="fc" id="L132">    return filterList;</span>
  }

  /**
   * Creates a HBase Filter object representation of labelReg predicate
   *
   * @param reg the pattern to filter for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getLabelRegFilter(@Nonnull Pattern reg, boolean negate) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">    return new SingleColumnValueFilter(</span>
      CF_META_BYTES,
      COL_LABEL_BYTES,
      negate ? CompareFilter.CompareOp.NOT_EQUAL : CompareFilter.CompareOp.EQUAL,
<span class="fc" id="L147">      new RegexStringComparator(reg.pattern())</span>
    );
  }

  /**
   * Creates a HBase Filter object representation of propEquals predicate
   *
   * @param key the property key to filter for
   * @param value the value to filter for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getPropEqualsFilter(@Nonnull String key, @Nonnull PropertyValue value,
    boolean negate) {
    // Handle negation
<span class="fc bfc" id="L162" title="All 2 branches covered.">    CompareFilter.CompareOp compareOp = negate ? CompareFilter.CompareOp.NOT_EQUAL :</span>
      CompareFilter.CompareOp.EQUAL;
<span class="fc bfc" id="L164" title="All 2 branches covered.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ONE :</span>
      FilterList.Operator.MUST_PASS_ALL;

<span class="fc" id="L167">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L169">    SingleColumnValueFilter valueFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_VALUE_BYTES,
<span class="fc" id="L171">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L173">      PropertyValueUtils.BytesUtils.getRawBytesWithoutType(value));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L176">    valueFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L178">    SingleColumnValueFilter typeFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_TYPE_BYTES,
<span class="fc" id="L180">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L182">      PropertyValueUtils.BytesUtils.getTypeByte(value));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L185">    typeFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L187">    filterList.addFilter(valueFilter);</span>
<span class="fc" id="L188">    filterList.addFilter(typeFilter);</span>
<span class="fc" id="L189">    return filterList;</span>
  }

  /**
   * Creates a HBase Filter object representation of propReg predicate
   *
   * @param key the property key to filter for
   * @param reg the pattern to search for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getPropRegFilter(@Nonnull String key, @Nonnull Pattern reg, boolean negate) {
    // Handle negation
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">    CompareFilter.CompareOp compareOp = negate ? CompareFilter.CompareOp.NOT_EQUAL :</span>
      CompareFilter.CompareOp.EQUAL;
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ONE :</span>
      FilterList.Operator.MUST_PASS_ALL;

<span class="fc" id="L207">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L209">    SingleColumnValueFilter valueFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_VALUE_BYTES,
<span class="fc" id="L211">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L213">      new RegexStringComparator(reg.pattern()));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L216">    valueFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L218">    SingleColumnValueFilter typeFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_TYPE_BYTES,
<span class="fc" id="L220">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L222">      new byte[] {Type.STRING.getTypeByte()});</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L225">    typeFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L227">    filterList.addFilter(typeFilter);</span>
<span class="fc" id="L228">    filterList.addFilter(valueFilter);</span>
<span class="fc" id="L229">    return filterList;</span>
  }

  /**
   * Creates a HBase Filter object representation of propLargerThan predicate
   *
   * @param key the property key to filter for
   * @param min the property value that defines the minimum of the filter
   * @param include a flag to define if a value that is equal to min should be included
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getPropLargerThanFilter(@Nonnull String key, @Nonnull PropertyValue min,
    boolean include, boolean negate) {
    // Handle negation
<span class="fc bfc" id="L244" title="All 2 branches covered.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ONE :</span>
      FilterList.Operator.MUST_PASS_ALL;

    CompareFilter.CompareOp compareOp;
<span class="fc bfc" id="L248" title="All 2 branches covered.">    if (include) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">      if (negate) {</span>
<span class="fc" id="L250">        compareOp = CompareFilter.CompareOp.LESS;</span>
      } else {
<span class="fc" id="L252">        compareOp = CompareFilter.CompareOp.GREATER_OR_EQUAL;</span>
      }
    } else {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">      if (negate) {</span>
<span class="nc" id="L256">        compareOp = CompareFilter.CompareOp.LESS_OR_EQUAL;</span>
      } else {
<span class="fc" id="L258">        compareOp = CompareFilter.CompareOp.GREATER;</span>
      }
    }

<span class="fc" id="L262">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L264">    SingleColumnValueFilter valueFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_VALUE_BYTES,
<span class="fc" id="L266">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L268">      new BinaryComparator(PropertyValueUtils.BytesUtils.getRawBytesWithoutType(min)));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L271">    valueFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L273">    SingleColumnValueFilter typeFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_TYPE_BYTES,
<span class="fc bfc" id="L275" title="All 2 branches covered.">      Bytes.toBytesBinary(key),</span>
      negate ? CompareFilter.CompareOp.NOT_EQUAL : CompareFilter.CompareOp.EQUAL,
<span class="fc" id="L277">      PropertyValueUtils.BytesUtils.getTypeByte(min));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L280">    typeFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L282">    filterList.addFilter(valueFilter);</span>
<span class="fc" id="L283">    filterList.addFilter(typeFilter);</span>
<span class="fc" id="L284">    return filterList;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>