<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GradoopHBaseConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop HBase</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.storage.hbase.config</a> &gt; <span class="el_source">GradoopHBaseConfig.java</span></div><h1>GradoopHBaseConfig.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.storage.hbase.config;

import org.apache.commons.lang3.StringUtils;
import org.apache.hadoop.hbase.TableName;
import org.gradoop.common.model.impl.pojo.EPGMEdgeFactory;
import org.gradoop.common.model.impl.pojo.EPGMGraphHeadFactory;
import org.gradoop.common.model.impl.pojo.EPGMVertexFactory;
import org.gradoop.storage.common.config.GradoopStoreConfig;
import org.gradoop.storage.hbase.impl.api.EdgeHandler;
import org.gradoop.storage.hbase.impl.api.GraphHeadHandler;
import org.gradoop.storage.hbase.impl.api.VertexHandler;
import org.gradoop.storage.hbase.impl.constants.HBaseConstants;
import org.gradoop.storage.hbase.impl.handler.HBaseEdgeHandler;
import org.gradoop.storage.hbase.impl.handler.HBaseGraphHeadHandler;
import org.gradoop.storage.hbase.impl.handler.HBaseVertexHandler;
import org.gradoop.storage.hbase.utils.RegionSplitter;
import org.gradoop.storage.hbase.utils.RowKeyDistributor;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Configuration class for using HBase with Gradoop.
 */
public class GradoopHBaseConfig implements GradoopStoreConfig {

  /**
   * Definition for serialize version control
   */
  private static final int serialVersionUID = 23;

  /**
   * Graph table name.
   */
  private final String graphTableName;

  /**
   * Vertex table name.
   */
  private final String vertexTableName;

  /**
   * Edge table name.
   */
  private final String edgeTableName;

  /**
   * Graph head handler.
   */
  private final GraphHeadHandler graphHeadHandler;

  /**
   * Vertex handler.
   */
  private final VertexHandler vertexHandler;

  /**
   * Edge handler.
   */
  private final EdgeHandler edgeHandler;

  /**
   * Creates a new Configuration.
   *
   * @param graphHeadHandler            graph head handler
   * @param vertexHandler               vertex handler
   * @param edgeHandler                 edge handler
   * @param graphTableName              graph table name
   * @param vertexTableName             vertex table name
   * @param edgeTableName               edge table name
   */
  private GradoopHBaseConfig(
    GraphHeadHandler graphHeadHandler,
    VertexHandler vertexHandler,
    EdgeHandler edgeHandler,
    String graphTableName,
    String vertexTableName,
    String edgeTableName
<span class="fc" id="L94">  ) {</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">    checkArgument(!StringUtils.isEmpty(graphTableName),</span>
      &quot;Graph table name was null or empty&quot;);
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">    checkArgument(!StringUtils.isEmpty(vertexTableName),</span>
      &quot;Vertex table name was null or empty&quot;);
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">    checkArgument(!StringUtils.isEmpty(edgeTableName),</span>
      &quot;Edge table name was null or empty&quot;);

<span class="fc" id="L102">    this.graphTableName = graphTableName;</span>
<span class="fc" id="L103">    this.vertexTableName = vertexTableName;</span>
<span class="fc" id="L104">    this.edgeTableName = edgeTableName;</span>

<span class="fc" id="L106">    this.graphHeadHandler = checkNotNull(graphHeadHandler, &quot;GraphHeadHandler was null&quot;);</span>
<span class="fc" id="L107">    this.vertexHandler = checkNotNull(vertexHandler, &quot;VertexHandler was null&quot;);</span>
<span class="fc" id="L108">    this.edgeHandler = checkNotNull(edgeHandler, &quot;EdgeHandler was null&quot;);</span>
<span class="fc" id="L109">  }</span>

  /**
   * Creates a new Configuration.
   *
   * @param config          Gradoop configuration
   * @param graphTableName  graph table name
   * @param vertexTableName vertex table name
   * @param edgeTableName   edge table name
   */
  private GradoopHBaseConfig(
    GradoopHBaseConfig config,
    String graphTableName,
    String vertexTableName,
    String edgeTableName
  ) {
<span class="fc" id="L125">    this(config.getGraphHeadHandler(),</span>
<span class="fc" id="L126">      config.getVertexHandler(),</span>
<span class="fc" id="L127">      config.getEdgeHandler(),</span>
      graphTableName,
      vertexTableName,
      edgeTableName);
<span class="fc" id="L131">  }</span>

  /**
   * Creates a default Configuration using POJO handlers for vertices, edges
   * and graph heads and default table names.
   *
   * @return Default Gradoop HBase configuration.
   */
  public static GradoopHBaseConfig getDefaultConfig() {
<span class="fc" id="L140">    GraphHeadHandler graphHeadHandler = new HBaseGraphHeadHandler(new EPGMGraphHeadFactory());</span>
<span class="fc" id="L141">    VertexHandler vertexHandler = new HBaseVertexHandler(new EPGMVertexFactory());</span>
<span class="fc" id="L142">    EdgeHandler edgeHandler = new HBaseEdgeHandler(new EPGMEdgeFactory());</span>

<span class="fc" id="L144">    return new GradoopHBaseConfig(</span>
      graphHeadHandler,
      vertexHandler,
      edgeHandler,
      HBaseConstants.DEFAULT_TABLE_GRAPHS,
      HBaseConstants.DEFAULT_TABLE_VERTICES,
      HBaseConstants.DEFAULT_TABLE_EDGES
    );
  }

  /**
   * Creates a Gradoop HBase configuration based on the given arguments.
   *
   * @param gradoopConfig   Gradoop configuration
   * @param graphTableName  graph table name
   * @param vertexTableName vertex table name
   * @param edgeTableName   edge table name
   *
   * @return Gradoop HBase configuration
   */
  public static GradoopHBaseConfig createConfig(
    GradoopHBaseConfig gradoopConfig,
    String graphTableName,
    String vertexTableName,
    String edgeTableName
  ) {
<span class="fc" id="L170">    return new GradoopHBaseConfig(gradoopConfig, graphTableName, vertexTableName, edgeTableName);</span>
  }

  /**
   * Get vertex table name
   *
   * @return vertex table name
   */
  public TableName getVertexTableName() {
<span class="fc" id="L179">    return TableName.valueOf(vertexTableName);</span>
  }

  /**
   * Get edge table name
   *
   * @return edge table name
   */
  public TableName getEdgeTableName() {
<span class="fc" id="L188">    return TableName.valueOf(edgeTableName);</span>
  }

  /**
   * Get graph table name
   *
   * @return graph table name
   */
  public TableName getGraphTableName() {
<span class="fc" id="L197">    return TableName.valueOf(graphTableName);</span>
  }

  /**
   * Get graph head handler
   *
   * @return graph head handler
   */
  public GraphHeadHandler getGraphHeadHandler() {
<span class="fc" id="L206">    return graphHeadHandler;</span>
  }

  /**
   * Get vertex handler
   *
   * @return vertex handler
   */
  public VertexHandler getVertexHandler() {
<span class="fc" id="L215">    return vertexHandler;</span>
  }

  /**
   * Get edge handler
   *
   * @return edge handler
   */
  public EdgeHandler getEdgeHandler() {
<span class="fc" id="L224">    return edgeHandler;</span>
  }

  /**
   * Enable/Disable the usage of pre-splitting regions at the moment of table creation.
   * If the HBase table size grows, it should be created with pre-split regions in order to avoid
   * region hotspots. If certain region servers are stressed by very intensive write/read
   * operations, HBase may drop that region server because the Zookeeper connection will timeout.
   *
   * Note that this flag has no effect if the tables already exist.
   *
   * @param numberOfRegions the number of regions used for splitting
   * @return this modified config
   */
  public GradoopHBaseConfig enablePreSplitRegions(final int numberOfRegions) {
<span class="fc" id="L239">    RegionSplitter.getInstance().setNumberOfRegions(numberOfRegions);</span>
<span class="fc" id="L240">    this.vertexHandler.setPreSplitRegions(true);</span>
<span class="fc" id="L241">    this.edgeHandler.setPreSplitRegions(true);</span>
<span class="fc" id="L242">    this.graphHeadHandler.setPreSplitRegions(true);</span>
<span class="fc" id="L243">    return this;</span>
  }

  /**
   * Enable/Disable the usage of a spreading byte as prefix of each HBase row key. This affects
   * reading and writing from/to HBase.
   *
   * Records in HBase are sorted lexicographically by the row key. This allows fast access to
   * an individual record by its key and fast fetching of a range of data given start and stop keys.
   * But writing records with such naive keys will cause hotspotting because of how HBase writes
   * data to its Regions. With this option you can disable this hotspotting.
   *
   * @param bucketCount the number of spreading bytes to use
   * @return this modified config
   */
  public GradoopHBaseConfig useSpreadingByte(final int bucketCount) {
<span class="fc" id="L259">    RowKeyDistributor.getInstance().setBucketCount((byte) bucketCount);</span>
<span class="fc" id="L260">    this.vertexHandler.setSpreadingByteUsage(true);</span>
<span class="fc" id="L261">    this.edgeHandler.setSpreadingByteUsage(true);</span>
<span class="fc" id="L262">    this.graphHeadHandler.setSpreadingByteUsage(true);</span>
<span class="fc" id="L263">    return this;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>