<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VertexFusor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.model.impl.operators.layouting.functions</a> &gt; <span class="el_source">VertexFusor.java</span></div><h1>VertexFusor.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.model.impl.operators.layouting.functions;

import org.apache.flink.api.common.functions.FlatJoinFunction;
import org.apache.flink.api.common.functions.GroupReduceFunction;
import org.apache.flink.api.common.functions.JoinFunction;
import org.apache.flink.api.common.typeinfo.TypeHint;
import org.apache.flink.api.java.DataSet;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.api.java.tuple.Tuple3;
import org.apache.flink.util.Collector;
import org.gradoop.flink.model.impl.operators.layouting.util.LEdge;
import org.gradoop.flink.model.impl.operators.layouting.util.LGraph;
import org.gradoop.flink.model.impl.operators.layouting.util.LVertex;
import org.gradoop.flink.model.impl.operators.layouting.util.Vector;

import java.util.Random;

/**
 * Simplifies the graph by combining similar vertices to super-vertices using a
 * Comparison-Function and a threshold.
 */
public class VertexFusor {
  /**
   * The VertexCompareFunction to use to find similar vertices
   */
  protected VertexCompareFunction compareFunction;
  /**
   * Only consider vertices as similar if their similarity is larger then this value
   */
  protected double threshold;

  /**
   * Construct new VertexFusor
   *
   * @param compareFunction The VertexCompareFunction to use to find similar vertices
   * @param threshold       Only consider vertices as similar if their similarity is larger then
   *                        this
   *                        value
   */
<span class="fc" id="L55">  public VertexFusor(VertexCompareFunction compareFunction, double threshold) {</span>
<span class="fc" id="L56">    this.compareFunction = compareFunction;</span>
<span class="fc" id="L57">    this.threshold = threshold;</span>
<span class="fc" id="L58">  }</span>

  /**
   * Execute the operation. Should be called iteratively. A single call is usually not enough for
   * practical results.
   *
   * @param graph The graph to simplify
   * @return A tuple containing the vertices and edges of the simplified graph
   */
  public LGraph execute(LGraph graph) {
<span class="fc" id="L68">    DataSet&lt;LVertex&gt; vertices = graph.getVertices();</span>
<span class="fc" id="L69">    DataSet&lt;LEdge&gt; edges = graph.getEdges();</span>

<span class="fc" id="L71">    DataSet&lt;Tuple2&lt;LVertex, Boolean&gt;&gt; classifiedVertices = chooseDonorsAndAcceptors(vertices);</span>

<span class="fc" id="L73">    DataSet&lt;Tuple2&lt;LVertex, LVertex&gt;&gt; fusions = generateFusionCandidates(classifiedVertices, edges);</span>

<span class="fc" id="L75">    DataSet&lt;LVertex&gt; superVertices = fusions.groupBy(&quot;1.0&quot;).reduceGroup(new SuperVertexGenerator());</span>

<span class="fc" id="L77">    DataSet&lt;LVertex&gt; remainingVertices = findRemainingVertices(fusions, vertices, superVertices);</span>

<span class="fc" id="L79">    vertices = remainingVertices.union(superVertices);</span>

<span class="fc" id="L81">    edges = fixEdgeReferences(edges, fusions);</span>

<span class="fc" id="L83">    edges = edges.groupBy(LEdge.SOURCE_ID_POSITION, LEdge.TARGET_ID_POSITION).reduce((a, b) -&gt; {</span>
<span class="fc" id="L84">      a.addSubEdge(b.getId());</span>
<span class="fc" id="L85">      a.addSubEdges(b.getSubEdges());</span>
<span class="fc" id="L86">      return a;</span>
    });

<span class="fc" id="L89">    return new LGraph(vertices, edges);</span>
  }

  /**
   * Splits the vertices randomly into donor and acceptor-vertices (~50/50).
   *
   * @param vertices vertices to classify
   * @return {@code Tuple2&lt;LVertex, Boolean&gt;}. If the boolean is true, the vertex is an acceptor
   */
  protected DataSet&lt;Tuple2&lt;LVertex, Boolean&gt;&gt; chooseDonorsAndAcceptors(DataSet&lt;LVertex&gt; vertices) {
<span class="fc" id="L99">    final Random rng = new Random();</span>
<span class="fc" id="L100">    return vertices.map(v -&gt; new Tuple2&lt;&gt;(v, rng.nextBoolean()))</span>
<span class="fc" id="L101">      .returns(new TypeHint&lt;Tuple2&lt;LVertex, Boolean&gt;&gt;() {</span>
      });
  }

  /**
   * Finds connected vertices by joining with the edges. Finds out if the two vertices should be
   * merged together and if so outputs a tuple for each merge.
   *
   * @param classifiedVertices The vertices (split into donors and acceptors)
   * @param edges              The edges
   * @return {@code Tuple2&lt;LVertex, LVertex&gt;} for each merge. f0 is the donor and f1 the acceptor
   * for the
   * merge.
   */
  protected DataSet&lt;Tuple2&lt;LVertex, LVertex&gt;&gt; generateFusionCandidates(
    DataSet&lt;Tuple2&lt;LVertex, Boolean&gt;&gt; classifiedVertices, DataSet&lt;LEdge&gt; edges) {
<span class="fc" id="L117">    return edges.join(classifiedVertices).where(LEdge.SOURCE_ID_POSITION).equalTo(&quot;0.&quot; + LVertex.ID_POSITION)</span>
<span class="fc" id="L118">      .join(classifiedVertices).where(&quot;0.&quot; + LEdge.TARGET_ID_POSITION).equalTo(&quot;0.&quot; + LVertex.ID_POSITION)</span>
<span class="fc" id="L119">      .with(new CandidateGenerator(compareFunction, threshold)).groupBy(&quot;0.0&quot;)</span>
<span class="pc bnc" id="L120" title="All 2 branches missed.">      .reduce((a, b) -&gt; (a.f2 &gt; b.f2) ? a : b).map(c -&gt; new Tuple2&lt;&gt;(c.f0, c.f1))</span>
<span class="fc" id="L121">      .returns(new TypeHint&lt;Tuple2&lt;LVertex, LVertex&gt;&gt;() { });</span>
  }

  /**
   * There are some vertices that have neither become super-vertices nor have been merged with a
   * super vertex. Find them so they can be copied to the simplified graph.
   *
   * @param fusions       The merges that are to be performed in this iteration
   * @param vertices      The original vertices of the input graph
   * @param superVertices The newly created super-vertices
   * @return All vertices that have to be copied to the output-graph
   */
  protected DataSet&lt;LVertex&gt; findRemainingVertices(DataSet&lt;Tuple2&lt;LVertex, LVertex&gt;&gt; fusions,
    DataSet&lt;LVertex&gt; vertices, DataSet&lt;LVertex&gt; superVertices) {
<span class="fc" id="L135">    DataSet&lt;LVertex&gt; remainingVertices =</span>
<span class="fc" id="L136">      vertices.leftOuterJoin(superVertices).where(LVertex.ID_POSITION).equalTo(LVertex.ID_POSITION)</span>
<span class="fc" id="L137">        .with(new FlatJoinFunction&lt;LVertex, LVertex, LVertex&gt;() {</span>
          @Override
          public void join(LVertex lVertex, LVertex lVertex2, Collector&lt;LVertex&gt; collector) {
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (lVertex2 == null) {</span>
<span class="fc" id="L141">              collector.collect(lVertex);</span>
            }
<span class="fc" id="L143">          }</span>
        });

<span class="fc" id="L146">    remainingVertices =</span>
<span class="fc" id="L147">      remainingVertices.leftOuterJoin(fusions).where(LVertex.ID_POSITION).equalTo(&quot;0.&quot; + LVertex.ID_POSITION)</span>
<span class="fc" id="L148">        .with(new FlatJoinFunction&lt;LVertex, Tuple2&lt;LVertex, LVertex&gt;, LVertex&gt;() {</span>
          @Override
          public void join(LVertex lVertex, Tuple2&lt;LVertex, LVertex&gt; lVertexLVertexDoubleTuple3,
            Collector&lt;LVertex&gt; collector) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (lVertexLVertexDoubleTuple3 == null) {</span>
<span class="fc" id="L153">              collector.collect(lVertex);</span>
            }
<span class="fc" id="L155">          }</span>
        });
<span class="fc" id="L157">    return remainingVertices;</span>
  }

  /**
   * When combining two vertices into one the edges of the old vertices have to be modified to
   * point to the new vertex.
   *
   * @param edges   The edges of the input-graph
   * @param fusions The merges performed in the current iteration
   * @return The &quot;fixed&quot; edges for the output-graph
   */
  protected DataSet&lt;LEdge&gt; fixEdgeReferences(DataSet&lt;LEdge&gt; edges,
    DataSet&lt;Tuple2&lt;LVertex, LVertex&gt;&gt; fusions) {
<span class="fc" id="L170">    edges = edges.leftOuterJoin(fusions).where(LEdge.SOURCE_ID_POSITION).equalTo(&quot;0.&quot; + LVertex.ID_POSITION)</span>
<span class="fc" id="L171">      .with(new JoinFunction&lt;LEdge, Tuple2&lt;LVertex, LVertex&gt;, LEdge&gt;() {</span>
        @Override
        public LEdge join(LEdge lEdge, Tuple2&lt;LVertex, LVertex&gt; lVertexLVertexDoubleTuple3) {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">          if (lVertexLVertexDoubleTuple3 != null) {</span>
<span class="nc" id="L175">            lEdge.setSourceId(lVertexLVertexDoubleTuple3.f1.getId());</span>
          }
<span class="fc" id="L177">          return lEdge;</span>
        }
      });

<span class="fc" id="L181">    edges = edges.leftOuterJoin(fusions).where(LEdge.TARGET_ID_POSITION).equalTo(&quot;0.&quot; + LVertex.ID_POSITION)</span>
<span class="fc" id="L182">      .with(new JoinFunction&lt;LEdge, Tuple2&lt;LVertex, LVertex&gt;, LEdge&gt;() {</span>
        @Override
        public LEdge join(LEdge lEdge, Tuple2&lt;LVertex, LVertex&gt; lVertexLVertexDoubleTuple3) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">          if (lVertexLVertexDoubleTuple3 != null) {</span>
<span class="fc" id="L186">            lEdge.setTargetId(lVertexLVertexDoubleTuple3.f1.getId());</span>
          }
<span class="fc" id="L188">          return lEdge;</span>
        }
      });
<span class="fc" id="L191">    return edges;</span>
  }

  /**
   * Finds out if two given vertices could be merged into one and how &quot;good&quot; this merge would be.
   * The strange signature of the join function is needed to be able to directly use it in the
   * join of generateFusionCandidates().
   */
  protected static class CandidateGenerator implements
    FlatJoinFunction&lt;Tuple2&lt;LEdge, Tuple2&lt;LVertex, Boolean&gt;&gt;, Tuple2&lt;LVertex, Boolean&gt;,
      Tuple3&lt;LVertex, LVertex, Double&gt;&gt; {

    /**
     * ComparisonFunction to use to compute similarity of vertices
     */
    protected VertexCompareFunction cf;
    /**
     * Minimum similarity to allow merge
     */
    protected Double threshold;

    /**
     * Construct new instance
     *
     * @param cf        ComparisonFunction to use to compute similarity of vertices
     * @param threshold Minimum similarity to allow merge
     */
<span class="fc" id="L218">    public CandidateGenerator(VertexCompareFunction cf, Double threshold) {</span>
<span class="fc" id="L219">      this.cf = cf;</span>
<span class="fc" id="L220">      this.threshold = threshold;</span>
<span class="fc" id="L221">    }</span>

    @Override
    public void join(Tuple2&lt;LEdge, Tuple2&lt;LVertex, Boolean&gt;&gt; source,
      Tuple2&lt;LVertex, Boolean&gt; target, Collector&lt;Tuple3&lt;LVertex, LVertex, Double&gt;&gt; collector) throws
      Exception {

<span class="fc" id="L228">      LVertex sourceVertex = source.f1.f0;</span>
<span class="fc" id="L229">      boolean sourceType = source.f1.f1;</span>

<span class="fc" id="L231">      LVertex targetVertex = target.f0;</span>
<span class="fc" id="L232">      boolean targetType = target.f1;</span>

      // Can not merge two vertices of the same type (donor/acceptor)
<span class="fc bfc" id="L235" title="All 2 branches covered.">      if (sourceType == targetType) {</span>
<span class="fc" id="L236">        return;</span>
      }

<span class="fc" id="L239">      Double similarity = cf.compare(sourceVertex, targetVertex);</span>

      // Can not merge vertices that are not similar enough
<span class="fc bfc" id="L242" title="All 2 branches covered.">      if (similarity &lt; threshold) {</span>
<span class="fc" id="L243">        return;</span>
      }

      // The acceptor-vertex (targetType==true) MUST be the second element of the tuple
<span class="fc bfc" id="L247" title="All 2 branches covered.">      if (targetType) {</span>
<span class="fc" id="L248">        collector.collect(new Tuple3&lt;&gt;(sourceVertex, targetVertex, similarity));</span>
      } else {
<span class="fc" id="L250">        collector.collect(new Tuple3&lt;&gt;(targetVertex, sourceVertex, similarity));</span>
      }

<span class="fc" id="L253">    }</span>
  }

  /**
   * Combines multiple vertices into a single super-vertex. The created super-vertex inherits the
   * id of the acceptor. The position of the super-vertex is a weighted average of all
   * participating vertices.
   */
<span class="fc" id="L261">  protected static class SuperVertexGenerator implements</span>
    GroupReduceFunction&lt;Tuple2&lt;LVertex, LVertex&gt;, LVertex&gt; {

    /**
     * Combine vertices
     *
     * @param iterable  The vertices to combine. f0 contains donor-vertices and f1 contains
     *                  (always the same) acceptor vertex.
     * @param collector Collector for the resuls
     */
    @Override
    public void reduce(Iterable&lt;Tuple2&lt;LVertex, LVertex&gt;&gt; iterable,
      Collector&lt;LVertex&gt; collector) {
<span class="fc" id="L274">      int count = 0;</span>
<span class="fc" id="L275">      Vector positionSum = new Vector();</span>
<span class="fc" id="L276">      LVertex self = null;</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">      for (Tuple2&lt;LVertex, LVertex&gt; t : iterable) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L280">          self = t.f1;</span>
<span class="fc" id="L281">          count = t.f1.getCount();</span>
<span class="fc" id="L282">          positionSum.mAdd(t.f1.getPosition().mul(t.f1.getCount()));</span>
        }
<span class="fc" id="L284">        count += t.f0.getCount();</span>
<span class="fc" id="L285">        positionSum.mAdd(t.f0.getPosition().mul(t.f0.getCount()));</span>
<span class="fc" id="L286">        self.addSubVertex(t.f0.getId());</span>
<span class="fc" id="L287">        self.addSubVertices(t.f0.getSubVertices());</span>
<span class="fc" id="L288">      }</span>

<span class="fc" id="L290">      self.setPosition(positionSum.div(count));</span>

<span class="fc" id="L292">      collector.collect(self);</span>
<span class="fc" id="L293">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>