<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GradoopRootConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.io.impl.parquet.plain.common</a> &gt; <span class="el_source">GradoopRootConverter.java</span></div><h1>GradoopRootConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.io.impl.parquet.plain.common;

import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.parquet.io.api.Binary;
import org.apache.parquet.io.api.Converter;
import org.apache.parquet.io.api.GroupConverter;
import org.apache.parquet.io.api.PrimitiveConverter;
import org.apache.parquet.schema.MessageType;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.id.GradoopIdSet;
import org.gradoop.common.model.impl.properties.Properties;
import org.gradoop.common.model.impl.properties.PropertyValue;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.LongConsumer;

/**
 * Root parquet group converter for EPGM elements.
 *
 * @param &lt;R&gt; the record type
 */
public abstract class GradoopRootConverter&lt;R&gt; extends GroupConverter {

  /**
   * the current record to be read
   */
  protected R record;

  /**
   * Contains every registered converter by addressed field name.
   */
<span class="fc" id="L49">  protected final Map&lt;String, Converter&gt; converterMap = new HashMap&lt;&gt;();</span>
  /**
   * Array of all converters in-order of the fields based on the given {@link MessageType} during converter
   * creation.
   */
  private final Converter[] converters;

  /**
   * Creates a new root converter based on the given record type ({@link MessageType}).
   *
   * @apiNote the {@link GradoopRootConverter&lt;R&gt;#initializeConverters} methods gets called before the
   * converter array is initialized and should be used to register every available field converter for the
   * request record type
   * @param requestedSchema the record type
   */
<span class="fc" id="L64">  public GradoopRootConverter(MessageType requestedSchema) {</span>
<span class="fc" id="L65">    this.initializeConverters();</span>

<span class="fc" id="L67">    this.converters = new Converter[requestedSchema.getFieldCount()];</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">    for (int i = 0; i &lt; this.converters.length; i++) {</span>
<span class="fc" id="L69">      String name = requestedSchema.getFieldName(i);</span>

<span class="fc" id="L71">      Converter converter = this.converterMap.get(name);</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">      if (converter == null) {</span>
<span class="nc" id="L73">        throw new NullPointerException(&quot;can't find converter for field: &quot; + name);</span>
      }

<span class="fc" id="L76">      this.converters[i] = converter;</span>
    }
<span class="fc" id="L78">  }</span>

  /**
   * Gets called once during construction to allow for the registration of field converters.
   */
  protected abstract void initializeConverters();

  /**
   * Creates a new record instance.
   *
   * @return the new record instance
   */
  protected abstract R createRecord();

  /**
   * Registers the converter for all fields with the given name.
   *
   * @param name the field name
   * @param converter the converter
   */
  protected void registerConverter(String name, Converter converter) {
<span class="fc" id="L99">    this.converterMap.put(name, converter);</span>
<span class="fc" id="L100">  }</span>

  /**
   * Returns the current record.
   *
   * @return the current record
   */
  public final R getCurrentRecord() {
<span class="fc" id="L108">    return this.record;</span>
  }

  @Override
  public Converter getConverter(int fieldIndex) {
<span class="fc" id="L113">    return this.converters[fieldIndex];</span>
  }

  @Override
  public void start() {
<span class="fc" id="L118">    this.record = this.createRecord();</span>
<span class="fc" id="L119">  }</span>

  @Override
  public void end() {
    // NOOP
<span class="fc" id="L124">  }</span>

  /**
   * Parquet converter for gradoop ids
   */
  protected static class GradoopIdConverter extends PrimitiveConverter {

    /**
     * The consumer for the read gradoop id
     */
    private final Consumer&lt;GradoopId&gt; consumer;

    /**
     * Creates a converter for gradoop ids.
     *
     * @param consumer the read value consumer
     */
<span class="fc" id="L141">    public GradoopIdConverter(Consumer&lt;GradoopId&gt; consumer) {</span>
<span class="fc" id="L142">      this.consumer = consumer;</span>
<span class="fc" id="L143">    }</span>

    @Override
    public void addBinary(Binary value) {
<span class="fc" id="L147">      GradoopId gradoopId = GradoopId.fromByteArray(value.getBytes());</span>
<span class="fc" id="L148">      this.consumer.accept(gradoopId);</span>
<span class="fc" id="L149">    }</span>
  }

  /**
   * Parquet converter for strings
   */
  protected static class StringConverter extends PrimitiveConverter {

    /**
     * The consumer for the read string
     */
    private final Consumer&lt;String&gt; consumer;

    /**
     * Creates a converter for strings.
     *
     * @param consumer the read value consumer
     */
<span class="fc" id="L167">    public StringConverter(Consumer&lt;String&gt; consumer) {</span>
<span class="fc" id="L168">      this.consumer = consumer;</span>
<span class="fc" id="L169">    }</span>

    @Override
    public void addBinary(Binary value) {
<span class="fc" id="L173">      String string = value.toStringUsingUTF8();</span>
<span class="fc" id="L174">      this.consumer.accept(string);</span>
<span class="fc" id="L175">    }</span>
  }

  /**
   * Parquet converter for {@link PropertyValue}
   */
  protected static class PropertyValueConverter extends PrimitiveConverter {

    /**
     * The consumer for the read {@link PropertyValue}
     */
    private final Consumer&lt;PropertyValue&gt; consumer;

    /**
     * Creates a converter for {@link PropertyValue}
     *
     * @param consumer the read value consumer
     */
<span class="fc" id="L193">    public PropertyValueConverter(Consumer&lt;PropertyValue&gt; consumer) {</span>
<span class="fc" id="L194">      this.consumer = consumer;</span>
<span class="fc" id="L195">    }</span>

    @Override
    public void addBinary(Binary value) {
<span class="fc" id="L199">      PropertyValue propertyValue = PropertyValue.fromRawBytes(value.getBytesUnsafe());</span>
<span class="fc" id="L200">      this.consumer.accept(propertyValue);</span>
<span class="fc" id="L201">    }</span>
  }

  /**
   * Parquet converter for longs
   */
  private static class LongValueConverter extends PrimitiveConverter {

    /**
     * The consumer for the read longs
     */
    private final LongConsumer consumer;

    /**
     * Creates a converter for longs.
     *
     * @param consumer the read value consumer
     */
<span class="nc" id="L219">    LongValueConverter(LongConsumer consumer) {</span>
<span class="nc" id="L220">      this.consumer = consumer;</span>
<span class="nc" id="L221">    }</span>

    @Override
    public void addLong(long value) {
<span class="nc" id="L225">      this.consumer.accept(value);</span>
<span class="nc" id="L226">    }</span>
  }

  /**
   * Parquet group converter for parquet spec compliant map key-value pairs
   */
  private static class KeyValueConverter extends GroupConverter {

    /**
     * Notifies the parent converter that the key-value pair got read.
     */
    private final Runnable notifier;

    /**
     * The key converter
     */
    private final Converter keyConverter;
    /**
     * The value converter
     */
    private final Converter valueConverter;

    /**
     * Creates a group converter for parquet spec compliant map key-value pairs.
     *
     * @param notifier the read completion notifier
     * @param keyConverter the key converter
     * @param valueConverter the value converter
     */
<span class="fc" id="L255">    KeyValueConverter(Runnable notifier, Converter keyConverter, Converter valueConverter) {</span>
<span class="fc" id="L256">      this.notifier = notifier;</span>
<span class="fc" id="L257">      this.keyConverter = keyConverter;</span>
<span class="fc" id="L258">      this.valueConverter = valueConverter;</span>
<span class="fc" id="L259">    }</span>

    @Override
    public Converter getConverter(int fieldIndex) {
<span class="fc bfc" id="L263" title="All 2 branches covered.">      if (fieldIndex == 0) {</span>
<span class="fc" id="L264">        return keyConverter;</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">      } else if (fieldIndex == 1) {</span>
<span class="fc" id="L266">        return valueConverter;</span>
      } else {
<span class="nc" id="L268">        throw new IndexOutOfBoundsException(&quot;key_value only consists of two fields: 'key', 'value'&quot;);</span>
      }
    }

    @Override
    public void start() {
<span class="fc" id="L274">    }</span>

    @Override
    public void end() {
<span class="fc" id="L278">      this.notifier.run();</span>
<span class="fc" id="L279">    }</span>
  }

  /**
   * Parquet group converter for {@link Properties}
   */
  protected static class PropertiesConverter extends GroupConverter {

    /**
     * The consumer for the read {@link Properties}
     */
    private final Consumer&lt;Properties&gt; consumer;
    /**
     * The key-value pair converter
     */
    private final Converter keyValueConverter;

    /**
     * The current properties
     */
    private Properties properties;
    /**
     * The latest key
     */
    private String key;
    /**
     * The latest value
     */
    private PropertyValue value;

    /**
     * Creates a group converter for {@link Properties}.
     *
     * @param consumer the read value consumer
     */
<span class="fc" id="L314">    public PropertiesConverter(Consumer&lt;Properties&gt; consumer) {</span>
<span class="fc" id="L315">      this.consumer = consumer;</span>

<span class="fc" id="L317">      this.keyValueConverter = new KeyValueConverter(() -&gt; this.properties.set(this.key, this.value),</span>
<span class="fc" id="L318">        new StringConverter(key -&gt; this.key = key), new PropertyValueConverter(value -&gt; this.value = value));</span>
<span class="fc" id="L319">    }</span>

    @Override
    public Converter getConverter(int fieldIndex) {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">      if (fieldIndex != 0) {</span>
<span class="nc" id="L324">        throw new IndexOutOfBoundsException(&quot;properties only consists of single field: 'key_value'&quot;);</span>
      }
<span class="fc" id="L326">      return this.keyValueConverter;</span>
    }

    @Override
    public void start() {
<span class="fc" id="L331">      this.properties = new Properties();</span>
<span class="fc" id="L332">    }</span>

    @Override
    public void end() {
<span class="fc" id="L336">      this.consumer.accept(this.properties);</span>
<span class="fc" id="L337">    }</span>
  }

  /**
   * Parquet group converter for parquet spec compliant list elements
   */
  private static class ListElementConverter extends GroupConverter {

    /**
     * The element's value converter
     */
    private final Converter converter;

    /**
     * Creates a group converter for parquet spec compliant list elements
     *
     * @param converter the element's value converter
     */
<span class="fc" id="L355">    ListElementConverter(Converter converter) {</span>
<span class="fc" id="L356">      this.converter = converter;</span>
<span class="fc" id="L357">    }</span>

    @Override
    public Converter getConverter(int fieldIndex) {
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">      if (fieldIndex != 0) {</span>
<span class="nc" id="L362">        throw new IndexOutOfBoundsException(&quot;list only consists of single field: 'element'&quot;);</span>
      }
<span class="fc" id="L364">      return this.converter;</span>
    }

    @Override
    public void start() {
<span class="fc" id="L369">    }</span>

    @Override
    public void end() {
<span class="fc" id="L373">    }</span>
  }

  /**
   * Parquet group converter for {@link GradoopIdSet}
   */
  protected static class GradoopIdSetConverter extends GroupConverter {

    /**
     * The consumer for the read {@link GradoopIdSet}
     */
    private final Consumer&lt;GradoopIdSet&gt; consumer;
    /**
     * The list element converter
     */
    private final Converter converter;

    /**
     * The current gradoop id set
     */
    private GradoopIdSet gradoopIdSet;

    /**
     * Creates a group converter for {@link GradoopIdSet}.
     *
     * @param consumer the read value consumer
     */
<span class="fc" id="L400">    public GradoopIdSetConverter(Consumer&lt;GradoopIdSet&gt; consumer) {</span>
<span class="fc" id="L401">      this.consumer = consumer;</span>

<span class="fc" id="L403">      this.converter = new ListElementConverter(</span>
<span class="fc" id="L404">        new GradoopIdConverter(id -&gt; this.gradoopIdSet.add(id)));</span>
<span class="fc" id="L405">    }</span>

    @Override
    public Converter getConverter(int fieldIndex) {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">      if (fieldIndex != 0) {</span>
<span class="nc" id="L410">        throw new IndexOutOfBoundsException(&quot;graph_ids only consists of single field: 'list'&quot;);</span>
      }
<span class="fc" id="L412">      return this.converter;</span>
    }

    @Override
    public void start() {
<span class="fc" id="L417">      this.gradoopIdSet = new GradoopIdSet();</span>
<span class="fc" id="L418">    }</span>

    @Override
    public void end() {
<span class="fc" id="L422">      this.consumer.accept(this.gradoopIdSet);</span>
<span class="fc" id="L423">    }</span>
  }

  /**
   * Parquet group converter for gradoop time intervals
   */
  protected static class TimeIntervalConverter extends GroupConverter {

    /**
     * The consumer for the read time interval
     */
    private final Consumer&lt;Tuple2&lt;Long, Long&gt;&gt; consumer;

    /**
     * The from time converter
     */
    private final Converter fromConverter;
    /**
     * The to time converter
     */
    private final Converter toConverter;

    /**
     * The current time interval
     */
    private Tuple2&lt;Long, Long&gt; timeInterval;

    /**
     * Creates a group converter for gradoop time intervals
     *
     * @param consumer the read value consumer
     */
<span class="nc" id="L455">    public TimeIntervalConverter(Consumer&lt;Tuple2&lt;Long, Long&gt;&gt; consumer) {</span>
<span class="nc" id="L456">      this.consumer = consumer;</span>

<span class="nc" id="L458">      this.fromConverter = new LongValueConverter(value -&gt; timeInterval.f0 = value);</span>
<span class="nc" id="L459">      this.toConverter = new LongValueConverter(value -&gt; timeInterval.f1 = value);</span>
<span class="nc" id="L460">    }</span>

    @Override
    public Converter getConverter(int fieldIndex) {
<span class="nc bnc" id="L464" title="All 2 branches missed.">      if (fieldIndex == 0) {</span>
<span class="nc" id="L465">        return fromConverter;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">      } else if (fieldIndex == 1) {</span>
<span class="nc" id="L467">        return toConverter;</span>
      } else {
<span class="nc" id="L469">        throw new IndexOutOfBoundsException(&quot;time interval only consists of two fields: 'from', 'to'&quot;);</span>
      }
    }

    @Override
    public void start() {
<span class="nc" id="L475">      this.timeInterval = new Tuple2&lt;&gt;();</span>
<span class="nc" id="L476">    }</span>

    @Override
    public void end() {
<span class="nc" id="L480">      this.consumer.accept(timeInterval);</span>
<span class="nc" id="L481">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>