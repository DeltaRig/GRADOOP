<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimeStampKeyFunction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Temporal</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.temporal.model.impl.operators.keyedgrouping.keys</a> &gt; <span class="el_source">TimeStampKeyFunction.java</span></div><h1>TimeStampKeyFunction.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2021 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.temporal.model.impl.operators.keyedgrouping.keys;

import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.tuple.Tuple2;
import org.gradoop.common.model.impl.properties.PropertyValue;
import org.gradoop.flink.model.api.functions.KeyFunctionWithDefaultValue;
import org.gradoop.temporal.model.api.TimeDimension;
import org.gradoop.temporal.model.impl.pojo.TemporalElement;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.temporal.ChronoField;
import java.time.temporal.TemporalField;
import java.util.Objects;

import static java.time.ZoneOffset.UTC;

/**
 * A key function extracting a time stamp of a {@link TemporalElement}.&lt;p&gt;
 * An optional {@link TemporalField} parameter can be given to this key function. In this case the time stamp
 * will be converted to a date (with a time zone set to {@link java.time.ZoneOffset#UTC UTC}) and the field
 * (e. g. {@link ChronoField#MONTH_OF_YEAR month}) will be extracted from that date.&lt;p&gt;
 * When no {@link TemporalField} is given, the time stamp will be used as is, in milliseconds since unix
 * epoch.&lt;p&gt;
 * The final grouping key will be stored on the super element as a property with key
 * {@code time_INTERVAL_FIELD_CALCULATEDFIELD} where {@code INTERVAL} is the {@link TimeDimension},
 * {@code FIELD} the {@link TimeDimension.Field} and {@code CALCULATEDFIELD} the {@link TemporalField}
 * extracted from the element. When no {@link TemporalField} is given, the property will just be called
 * {@code time_INTERVAL_FIELD}.&lt;p&gt;
 * When the extracted {@link TimeDimension.Field field} of the {@link TimeDimension} is set to a default
 * value and a {@link TemporalField} was set, a default value ({@code -1}) will be returned instead.
 * In this case no property will be set.
 *
 * @param &lt;T&gt; The type of the elements to group.
 */
public class TimeStampKeyFunction&lt;T extends TemporalElement&gt; implements KeyFunctionWithDefaultValue&lt;T, Long&gt; {

  /**
   * The time dimension of the temporal element to extract.
   */
  private final TimeDimension timeDimension;

  /**
   * The field of that dimension to extract.
   */
  private final TimeDimension.Field timeDimensionField;

  /**
   * The time field to calculate.
   */
  private final TemporalField fieldOfTimeStamp;

  /**
   * The property key used to store the grouping key on the super-element.
   */
  private final String targetPropertyKey;

  /**
   * Create a new instance of this grouping key function.
   *
   * @param timeDimension      The time dimension of the temporal element to consider.
   * @param timeDimensionField The field of that time dimension to consider.
   * @param fieldOfTimeStamp   The time field of that field to calculate. May be {@code null},
   *                           in that case nothing will be calculated, the time stamp will be
   *                           returned as is.
   */
  public TimeStampKeyFunction(TimeDimension timeDimension,
<span class="fc" id="L84">    TimeDimension.Field timeDimensionField, TemporalField fieldOfTimeStamp) {</span>
<span class="fc" id="L85">    this.timeDimension = Objects.requireNonNull(timeDimension);</span>
<span class="fc" id="L86">    this.timeDimensionField = Objects.requireNonNull(timeDimensionField);</span>
<span class="fc" id="L87">    this.fieldOfTimeStamp = fieldOfTimeStamp;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    this.targetPropertyKey = &quot;time_&quot; + timeDimension + &quot;_&quot; + timeDimensionField +</span>
      (fieldOfTimeStamp != null ? &quot;_&quot; + fieldOfTimeStamp : &quot;&quot;);
<span class="fc" id="L90">  }</span>

  @Override
  public Long getKey(T element) {
    final Tuple2&lt;Long, Long&gt; interval;
<span class="pc bpc" id="L95" title="1 of 3 branches missed.">    switch (timeDimension) {</span>
    case TRANSACTION_TIME:
<span class="fc" id="L97">      interval = element.getTransactionTime();</span>
<span class="fc" id="L98">      break;</span>
    case VALID_TIME:
<span class="fc" id="L100">      interval = element.getValidTime();</span>
<span class="fc" id="L101">      break;</span>
    default:
<span class="nc" id="L103">      throw new UnsupportedOperationException(</span>
        &quot;Time interval not supported by this element: &quot; + timeDimension);
    }
    final Long fieldValue;
<span class="pc bpc" id="L107" title="1 of 3 branches missed.">    switch (timeDimensionField) {</span>
    case FROM:
<span class="fc" id="L109">      fieldValue = interval.f0;</span>
<span class="fc bfc" id="L110" title="All 4 branches covered.">      if (fieldValue.equals(TemporalElement.DEFAULT_TIME_FROM) &amp;&amp; (fieldOfTimeStamp != null)) {</span>
<span class="fc" id="L111">        return getDefaultKey();</span>
      }
      break;
    case TO:
<span class="fc" id="L115">      fieldValue = interval.f1;</span>
<span class="fc bfc" id="L116" title="All 4 branches covered.">      if (fieldValue.equals(TemporalElement.DEFAULT_TIME_TO) &amp;&amp; (fieldOfTimeStamp != null)) {</span>
<span class="fc" id="L117">        return getDefaultKey();</span>
      }
      break;
    default:
<span class="nc" id="L121">      throw new UnsupportedOperationException(&quot;Field is not supported: &quot; + timeDimensionField);</span>
    }
<span class="fc bfc" id="L123" title="All 2 branches covered.">    if (fieldOfTimeStamp == null) {</span>
<span class="fc" id="L124">      return fieldValue;</span>
    }
<span class="fc" id="L126">    final LocalDateTime date = LocalDateTime.ofInstant(Instant.ofEpochMilli(fieldValue), UTC);</span>
<span class="fc" id="L127">    return fieldOfTimeStamp.getFrom(date);</span>
  }

  @Override
  public void addKeyToElement(T element, Object key) {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    if (!(key instanceof Long)) {</span>
<span class="nc" id="L133">      throw new IllegalArgumentException(&quot;Invalid type for key: &quot; + key.getClass().getSimpleName());</span>
    }
    // Do not set the key if field extraction is enabled and the key is -1
<span class="fc bfc" id="L136" title="All 4 branches covered.">    if (fieldOfTimeStamp == null || !getDefaultKey().equals(key)) {</span>
<span class="fc" id="L137">      element.setProperty(targetPropertyKey, PropertyValue.create(key));</span>
    }
<span class="fc" id="L139">  }</span>

  @Override
  public TypeInformation&lt;Long&gt; getType() {
<span class="fc" id="L143">    return BasicTypeInfo.LONG_TYPE_INFO;</span>
  }

  @Override
  public Long getDefaultKey() {
<span class="fc bfc" id="L148" title="All 2 branches covered.">    if (fieldOfTimeStamp == null) {</span>
<span class="pc bpc" id="L149" title="1 of 3 branches missed.">      switch (timeDimensionField) {</span>
      case FROM:
<span class="fc" id="L151">        return TemporalElement.DEFAULT_TIME_FROM;</span>
      case TO:
<span class="fc" id="L153">        return TemporalElement.DEFAULT_TIME_TO;</span>
      default:
<span class="nc" id="L155">        throw new UnsupportedOperationException(&quot;Field not supported: &quot; + timeDimensionField);</span>
      }
    }
<span class="fc" id="L158">    return -1L;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>